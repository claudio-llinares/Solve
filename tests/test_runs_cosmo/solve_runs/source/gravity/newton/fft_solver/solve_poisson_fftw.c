#include<stdio.h>
#include <math.h>
#include <stdlib.h>

#include <fftw3.h>

#include "../../../solve.h"
#include "../../../grid/init_grid.h"

#include "../../../libs/allocator.h"
#include "../../../libs/releaser.h"

#ifdef OPENMP
#include <omp.h>
#endif

#define index(i,j,k) ((i) + grid * ((j) + grid * (k)))

void transforms(double ***gr, double ***gi, double box, int grid, fftw_complex *data, fftw_plan p_backward);
void anti_transforms(double ***gr, double ***gi, double box, int grid, fftw_complex *data, fftw_plan p_forward);


//============================
// solve_poisson_fft
//============================
int solve_poisson_fftw(struct params *par, struct grids *grid, struct units *unit)
{
  // Solve Poisson's equation in a 3D uniform grid given a source.
  // No 4 pi G involved (it should come with the source if there is any).
  // No units (again, they come with the density).

  double ***gr, ***gi;
  //double Delta;

  int ix, iy, iz;
  int m, n, o;

  //double k2;   // k squared

  double sf, kf;  // for the green;s function

  double sf_kf, sf2;
  //double grid_Delta;  // optimization

  // Allocates stuff:
  //================
  alloc_double_3(&gr, par->grid, par->grid, par->grid);
  alloc_double_3(&gi, par->grid, par->grid, par->grid);
  //Delta = par->box / par->grid;

  // Conect input source with data structure here:
  //==============================================
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz) shared(gr, gi, par, grid)
  {
#pragma omp for schedule(static)
#endif
  for(ix = 0; ix<par->grid; ix++)
    {
      for(iy = 0; iy<par->grid; iy++)
	{
	  for(iz = 0; iz<par->grid; iz++)
	    {
	      gr[ix][iy][iz] = grid->source[ix][iy][iz];
	      gi[ix][iy][iz] = 0.0;
	    }
	}
    }
#ifdef OPENMP
  }
#endif

  // Do the FFT:
  //============
  //show_fft(gr, gi, box, grid, "debug.rho");  // for debuging.
  transforms(gr, gi, par->box, par->grid, grid->data, grid->p_backward);
  //show_fft(gr, gi, box, grid, "debug.fft");  // for debuging.

  // Multiply by discrete Green's function:
  //=======================================
  sf = par->box/(2.0*par->grid);
  kf = unit->twopi/par->box;
  sf_kf = sf*kf;
  sf2 = pow2(sf);
  //grid_Delta = par->grid*Delta;
  //m = -grid/2.0;
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz, o, m, n) shared(par, gr, gi, sf_kf, sf2, unit)
  {
#pragma omp for schedule(static)
#endif
  for(ix = 0; ix<par->grid; ix++)
    {
      m = -par->grid/2 + ix;
      n = -par->grid/2.0;
      for(iy = 0; iy<par->grid; iy++)
	{
	  o = -par->grid/2.0;
	  for(iz = 0; iz<par->grid; iz++)
	    {
	      //k2 = pow2((unit->twopi) * m/(grid_Delta)) +
	      //pow2((unit->twopi) * n/(grid_Delta)) +
	      //	pow2((unit->twopi) * o/(grid_Delta));
	      // Other Green's function:
	      if(m==0 && n==0 && o==0)
	      	{
	      	  gr[ix][iy][iz] = 0.0;
	      	  gi[ix][iy][iz] = 0.0;
	      	}
	      else
	      	{
		  gr[ix][iy][iz] *= -sf2 / 
		    (pow2(sin(sf_kf*m)) +
		     pow2(sin(sf_kf*n)) +
		     pow2(sin(sf_kf*o)) );
		  gi[ix][iy][iz] *= -sf2 / 
		    (pow2(sin(sf_kf*m)) +
		     pow2(sin(sf_kf*n)) +
		     pow2(sin(sf_kf*o)) );
		}
	      o++;
	    }
	  n++;
	}
      //m++;
    }
#ifdef OPENMP
    }
#endif

  // Come back:
  //===========
  anti_transforms(gr, gi, par->box, par->grid, grid->data, grid->p_forward);

  // Copy result into phi:
  //======================
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz) shared(gr, par, grid)
  {
#pragma omp for schedule(static)
#endif
  for(ix = 0; ix<par->grid; ix++)
    for(iy = 0; iy<par->grid; iy++)
      for(iz = 0; iz<par->grid; iz++)
	grid->phi[ix][iy][iz] = gr[ix][iy][iz];
#ifdef OPENMP
  }
#endif
  free_double_3(gr);
  free_double_3(gi);

  return 0;
    
}

//==========================
// nabla_phi
//==========================
void transforms(double ***gr, double ***gi, double box, int grid, fftw_complex *data, fftw_plan p_backward)
{

  // Calculates nabla(phi) given the spectrum generated by spectr.
  //
  // Returns:
  //             - Derivatives of the potential where before
  //               was the fourier transform.
  // Comments:
  //             - Strictly speaking, we should multiply by (-i) but
  //               as the numbers are gaussian, will be the same, so
  //               we don't do it.
  //             
  
  int ix, iy, iz;

  double Delta;

  int gover2 = grid/2;  // optimization
  int ix_gover2, iy_gover2, iz_gover2;

  double norm;  // normalization

  double twopi;

  Delta = box/grid;
  twopi = 2.0 * (4.0*atan(1.0));
  
  // Fill data according to FFTW:
  //=============================
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz) shared(data, gr, gi, grid)
  {
#pragma omp for schedule(static)
#endif
    for(ix=0; ix<grid; ix++)
    {
      for(iy=0; iy<grid; iy++)
	{
	  for(iz=0; iz<grid; iz++)
	    {
	      data[index(ix,iy,iz)][0] = (float)gr[ix][iy][iz];
	      data[index(ix,iy,iz)][1] = (float)gi[ix][iy][iz];
	    }
	}
    }
#ifdef OPENMP
  }
#endif
  // Do FFT:
  //========
  //fprintf(stderr, "Doing FFT...\n");
  //fprintf(stderr, "Calling fftw_execute... \n");
  fftw_execute(p_backward);
  //fprintf(stderr, "done\n");

  // Copy into output vector g (and normalizes):
  //============================================
  //The normalization is norm.
  norm = pow(Delta,3) / pow(sqrt(twopi),3);
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz, ix_gover2, iy_gover2, iz_gover2) shared(data, grid, gr, gi, gover2)
  {
#pragma omp for schedule(static)
#endif
  for(ix=0; ix<gover2; ix++)
    {
      ix_gover2 = ix+gover2;
      for(iy=0; iy<gover2; iy++)
	{
	  iy_gover2 = iy+gover2;
	  for(iz=0; iz<gover2; iz++)
	    {
	      iz_gover2 = iz+gover2;
	      // --- frecuencies:
	      gr[ix][iy][iz] = (double)data[index(ix_gover2,iy_gover2,iz_gover2)][0] * norm;
	      gi[ix][iy][iz] = (double)data[index(ix_gover2,iy_gover2,iz_gover2)][1] * norm;
	      // ++- frecuencies:
	      gr[ix_gover2][iy_gover2][iz] = (double)data[index(ix,iy,iz_gover2)][0] * norm; 
	      gi[ix_gover2][iy_gover2][iz] = (double)data[index(ix,iy,iz_gover2)][1] * norm; 
	      // -+- frecuencies:
	      gr[ix][iy_gover2][iz] = (double)data[index(ix_gover2,iy,iz_gover2)][0] * norm; 
	      gi[ix][iy_gover2][iz] = (double)data[index(ix_gover2,iy,iz_gover2)][1] * norm; 
	      // +-- frecuencies:
	      gr[ix_gover2][iy][iz] = (double)data[index(ix,iy_gover2,iz_gover2)][0] * norm; 
	      gi[ix_gover2][iy][iz] = (double)data[index(ix,iy_gover2,iz_gover2)][1] * norm;
	      
	      // --+ frecuencies:
	      gr[ix][iy][iz_gover2] = (double)data[index(ix_gover2,iy_gover2,iz)][0] * norm;
	      gi[ix][iy][iz_gover2] = (double)data[index(ix_gover2,iy_gover2,iz)][1] * norm;
	      // +++ frecuencies:
	      gr[ix_gover2][iy_gover2][iz_gover2] = (double)data[index(ix,iy,iz)][0] * norm; 
	      gi[ix_gover2][iy_gover2][iz_gover2] = (double)data[index(ix,iy,iz)][1] * norm; 
	      // -++ frecuencies:
	      gr[ix][iy_gover2][iz_gover2] = (double)data[index(ix_gover2,iy,iz)][0] * norm; 
	      gi[ix][iy_gover2][iz_gover2] = (double)data[index(ix_gover2,iy,iz)][1] * norm; 
	      // +-+ frecuencies:
	      gr[ix_gover2][iy][iz_gover2] = (double)data[index(ix,iy_gover2,iz)][0] * norm; 
	      gi[ix_gover2][iy][iz_gover2] = (double)data[index(ix,iy_gover2,iz)][1] * norm;
	    }
	}
    }
#ifdef OPENMP
	  }
#endif

}

//==========================
// nabla_phi
//==========================
void anti_transforms(double ***gr, double ***gi, double box, int grid, fftw_complex *data, fftw_plan p_forward)
{

  // Calculates nabla(phi) given the spectrum generated by spectr.
  //
  // Returns:
  //             - Derivatives of the potential where before
  //               was the fourier transform.
  // Comments:
  //             - Strictly speaking, we should multiply by (-i) but
  //               as the numbers are gaussian, will be the same, so
  //               we don't do it.
  //             
  
  int ix, iy, iz;

  double Delta;

  int gover2 = grid/2;

  double norm;  // optimization.
  int ix_gover2, iy_gover2, iz_gover2;

  double twopi;

  Delta = box/grid;
  twopi = 2.0 * (4.0*atan(1.0));
  
  // Fill data according to fftw:
  //=============================
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz, ix_gover2, iy_gover2, iz_gover2) shared(data, grid, gr, gi, gover2)
  {
#pragma omp for schedule(static)
#endif
  for(ix=0; ix<gover2; ix++)
    {
      ix_gover2 = ix+gover2;
      for(iy=0; iy<gover2; iy++)
	{
	  iy_gover2 = iy+gover2;
	  for(iz=0; iz<gover2; iz++)
	    {
	      iz_gover2 = iz+gover2;
	      // --- frecuencies:
	      data[index(ix_gover2,iy_gover2,iz_gover2)][0] = (float)gr[ix][iy][iz];
	      data[index(ix_gover2,iy_gover2,iz_gover2)][1] = (float)gi[ix][iy][iz];
	      // ++- frecuencies:
	      data[index(ix,iy,iz_gover2)][0] = (float)gr[ix_gover2][iy_gover2][iz];
	      data[index(ix,iy,iz_gover2)][1] = (float)gi[ix_gover2][iy_gover2][iz];
	      // -+- frecuencies:
	      data[index(ix_gover2,iy,iz_gover2)][0] = (float)gr[ix][iy_gover2][iz]; 
	      data[index(ix_gover2,iy,iz_gover2)][1] = (float)gi[ix][iy_gover2][iz]; 
	      // +-- frecuencies:
	      data[index(ix,iy_gover2,iz_gover2)][0] = (float)gr[ix_gover2][iy][iz]; 
	      data[index(ix,iy_gover2,iz_gover2)][1] = (float)gi[ix_gover2][iy][iz]; 
	      
	      // --+ frecuencies:
	      data[index(ix_gover2,iy_gover2,iz)][0] = (float)gr[ix][iy][iz_gover2]; 
	      data[index(ix_gover2,iy_gover2,iz)][1] = (float)gi[ix][iy][iz_gover2];
	      // +++ frecuencies:
	      data[index(ix,iy,iz)][0] = (float)gr[ix_gover2][iy_gover2][iz_gover2];
	      data[index(ix,iy,iz)][1] = (float)gi[ix_gover2][iy_gover2][iz_gover2];
	      // -++ frecuencies:
	      data[index(ix_gover2,iy,iz)][0] = (float)gr[ix][iy_gover2][iz_gover2];
	      data[index(ix_gover2,iy,iz)][1] = (float)gi[ix][iy_gover2][iz_gover2];
	      // +-+ frecuencies:
	      data[index(ix,iy_gover2,iz)][0] = (float)gr[ix_gover2][iy][iz_gover2];
	      data[index(ix,iy_gover2,iz)][1] = (float)gi[ix_gover2][iy][iz_gover2];
	    }
	}
    }
#ifdef OPENMP
  }
#endif
  
  // Do Fourier transform:
  //fprintf(stderr, "Antitransforming FFT...\n");
  //fprintf(stderr, "Calling fftw_execute... \n");
  fftw_execute(p_forward);
  //fprintf(stderr, "done\n");

  // Copy into output vector g (and normalizes):
  //============================================
  //The normalization is in the variable norm:
  norm = 1.0/pow3(Delta)/pow3(grid) * pow3(sqrt(twopi));
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz) shared(data, gr, gi, norm, grid)
  {
#pragma omp for schedule(static)
#endif
    for(ix=0; ix<grid; ix++)
      for(iy=0; iy<grid; iy++)      
	for(iz=0; iz<grid; iz++)      
	  {
	    gr[ix][iy][iz] = (double)data[index(ix,iy,iz)][0] * norm;		
	    gi[ix][iy][iz] = (double)data[index(ix,iy,iz)][1] * norm;
	  }
#ifdef OPENMP
  }
#endif

}


