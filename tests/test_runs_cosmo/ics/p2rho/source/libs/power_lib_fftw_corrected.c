#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<string.h>

#include <fftw3.h>

#include "cuad_min.h"

#include "allocator.h"
#include "releaser.h"

// Check:  
//         - limits in loop of normalization of sum and c_2.
//

#define pow2(x) ((x)*(x))
#define pow3(x) ((x)*(x)*(x))
#define pow4(x) ((x)*(x)*(x)*(x))
#define pow6(x) ((x)*(x)*(x)*(x)*(x)*(x))
#define index(i,j,k) ((i) + grid * ((j) + grid * (k)))

void transforms_power_corrected(double ***gr, double ***gi, int grid, double box, fftw_complex *data, fftw_plan p_backward);
double W(double k1, double k2, double k3, double kn);
double sinc(double x);
double C1(double x);
void jing(int grid, double Delta, double ***p3d2);
void get_1d(int grid, double Delta, double ***p3d2, double *p, double *phase);

//==================
// main
//==================
void power_corrected(double ***gr, double ***gi, double box, int grid, double *phase, double *p, int correct, fftw_complex *data, fftw_plan p_backward)
{

  // Calculates power spectrum of a given overdensity in a given grid of 
  // of a given box using FFTW.
  //
  // CAREFULL:  THIS ROUTINE CHANGE THE VARIABLES gr AND gi.
  //
  // Arguments:
  //            - phase = to return the phases.
  //            - p = to return the power spectrum
  //            - correct = flag for jing correction (0->don;t do it).
  // Comments:
  //            - phase and p should be allocated with sqrt(3.0)*par.grid+.5)
  //            places.
  //

  // Units:
  //        [x] = length of the box.
  //        [rho] = mean density of the universe for the given cosmology.
  //                (not necesarilly the mean density in the box).
  //        [mass] = whatever shift comes from this.
  //
  
  int i, j;
  int k;

  double Delta;  // spacing of the sampling (box/grid) (NR)

  double pi;
  double kn;

  double ***p3d2;

  pi = 4.0*atan(1.0);
  Delta = box/grid;
  kn = pi/Delta;

  fprintf(stderr, "Delta         = %lf\n", Delta);
  fprintf(stderr, "kn = pi/Delta = %lf\n", kn);

  // Allocates:
  //===========
  alloc_double_3(&p3d2, grid, grid, grid);

  // Do the FFT:
  //============
  transforms_power_corrected(gr, gi, grid, box, data, p_backward);

  // Calculates norm:
  //=================
  for(i=0; i<grid; i++)
    for(j=0; j<grid; j++)
	for(k=0; k<grid; k++)
	    p3d2[i][j][k] = pow2(gr[i][j][k]) + pow2(gi[i][j][k]);

  // Do Jing correction:
  //====================
  if(correct)
    {
      fprintf(stderr, "Doing Jing's correction...\n");
      jing(grid, Delta, p3d2);
    }
  else
    {
      fprintf(stderr, "NOT doing Jing's correction...\n");
    }	
	
  // Get mean value:
  //================
  get_1d(grid, Delta, p3d2, p, phase);

  
}

//==========================
// transforms_power
//==========================
void transforms_power_corrected(double ***gr, double ***gi, int grid, double box, fftw_complex *data, fftw_plan p_backward)
{

  // Calculates nabla(phi) given the spectrum generated by spectr.
  //
  // Returns:
  //             - Derivatives of the potential where before
  //               was the fourier transform.
  // Comments:
  //             - Strictly speaking, we should multiply by (-i) but
  //               as the numbers are gaussian, will be the same, so
  //               we don't do it.
  //             
  
  int ix, iy, iz;

  double Delta;

  // openmp stuff
  int gm1 = grid - 1;
  int gover2m1 = grid/2 - 1;
  int gover2 = grid/2;
  int ix_gover2, iy_gover2, iz_gover2;
  
  double norm;  // optimization

  double pi;
  double twopi;

  twopi = 2.0 * ( 4.0*atan(1.0) );
  pi = 4.0*atan(1.0);

  //static int first = 1;  // for the allocation and plans.

  Delta = box/grid;
  
  // Fill data according to fftw:
  //===========================
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz) shared(data, grid, gr, gi, gm1)
  {
#pragma omp for schedule(static)
#endif
  for(ix=0; ix<=gm1; ix++)
    {
      for(iy=0; iy<=gm1; iy++)
	{
	  for(iz=0; iz<=gm1; iz++)
	    {
	      data[index(ix,iy,iz)][0] = (float)gr[ix][iy][iz];
	      data[index(ix,iy,iz)][1] = (float)gi[ix][iy][iz];
	    }
	}
    }
#ifdef OPENMP
  }
#endif

  // Do FFT:
  //========
  //printf("Doing FFT...\n");
  fprintf(stderr, "Calling fftw_execute... \n");
  fftw_execute(p_backward);
  fprintf(stderr, "done\n");

  // Copy into output vector g (and normalizes):
  //============================================
  // The normalization is in the variable norm
  // ORIGINAL (LOOKS WRONG)
  // This one is compatible with the normalization used in p2rho for 
  // the test that where in the first version of the linear chapter.
  //norm = pow(Delta,3) / pow(sqrt(twopi),3);
  // The sqrt doesn't go because P=F(delta)**2.
  // The sqrt goes because we still don't have the pow2
  // This one is compatible with the particles given by grafic1.
  norm = sqrt(1.0 / pow3(grid) * pow3(Delta));
#ifdef OPENMP
#pragma omp parallel private(ix, iy, iz, ix_gover2, iy_gover2, iz_gover2) shared(gover2, data, grid, gr, gi, gover2m1, norm)
  {
#pragma omp for schedule(static)
#endif
  for(ix=0; ix<=gover2m1; ix++)
    {
      ix_gover2 = ix + gover2;
      for(iy=0; iy<=gover2m1; iy++)
	{
	  iy_gover2 = iy + gover2;
	  for(iz=0; iz<=gover2m1; iz++)
	    {
	      iz_gover2 = iz + gover2;
	      // --- frecuencies:
	      gr[ix][iy][iz] = (double)data[index(ix_gover2,iy_gover2,iz_gover2)][0] * norm;
	      gi[ix][iy][iz] = (double)data[index(ix_gover2,iy_gover2,iz_gover2)][1] * norm;
	      // ++- frecuencies:
	      gr[ix_gover2][iy_gover2][iz] = (double)data[index(ix,iy,iz_gover2)][0] * norm; 
	      gi[ix_gover2][iy_gover2][iz] = (double)data[index(ix,iy,iz_gover2)][1] * norm; 
	      // -+- frecuencies:
	      gr[ix][iy_gover2][iz] = (double)data[index(ix_gover2,iy,iz_gover2)][0] * norm; 
	      gi[ix][iy_gover2][iz] = (double)data[index(ix_gover2,iy,iz_gover2)][1] * norm; 
	      // +-- frecuencies:
	      gr[ix_gover2][iy][iz] = (double)data[index(ix,iy_gover2,iz_gover2)][0] * norm; 
	      gi[ix_gover2][iy][iz] = (double)data[index(ix,iy_gover2,iz_gover2)][1] * norm;
	      
	      // --+ frecuencies:
	      gr[ix][iy][iz_gover2] = (double)data[index(ix_gover2,iy_gover2,iz)][0] * norm;
	      gi[ix][iy][iz_gover2] = (double)data[index(ix_gover2,iy_gover2,iz)][1] * norm;
	      // +++ frecuencies:
	      gr[ix_gover2][iy_gover2][iz_gover2] = (double)data[index(ix,iy,iz)][0] * norm; 
	      gi[ix_gover2][iy_gover2][iz_gover2] = (double)data[index(ix,iy,iz)][1] * norm; 
	      // -++ frecuencies:
	      gr[ix][iy_gover2][iz_gover2] = (double)data[index(ix_gover2,iy,iz)][0] * norm; 
	      gi[ix][iy_gover2][iz_gover2] = (double)data[index(ix_gover2,iy,iz)][1] * norm; 
	      // +-+ frecuencies:
	      gr[ix_gover2][iy][iz_gover2] = (double)data[index(ix,iy_gover2,iz)][0] * norm; 
	      gi[ix_gover2][iy][iz_gover2] = (double)data[index(ix,iy_gover2,iz)][1] * norm;
	    }
	}
    }
#ifdef OPENMP
  }
#endif

  // Outputs the FFT:
  //=================
	if(0)
{	
  FILE *fp;
  int i, j, k, m, n, o;
  fp = fopen("fft.dat", "w");
  m = -grid/2;
  for(k=0; k<=grid-1; k++)	  
    {
      n = -grid/2;
      for(j=0; j<=grid-1; j++)
	{
	  o = -grid/2;
	  for(i=0; i<=grid-1; i++)	  
	    {
	      fprintf(fp, "%lg  %lg  %lg  %lg  %lg\n", 
		      2.0*pi*(double)o/(grid*Delta),
		      2.0*pi*(double)n/(grid*Delta),
		      2.0*pi*(double)m/(grid*Delta),
		      gr[i][j][k], 
		      gi[i][j][k]);
	      ++o;
	    }
	  ++n;
	}
      ++m;
    }
  fclose(fp);
	}

}

//==================================
// W
//==================================
double W(double k1, double k2, double k3, double kn)
{
  // W function in formula 22 of Jing.
  //
  // Arguments:
  //            - k1, k2, k3 = argument of the function
  //            - kn = nyquist frequency acording to Jing.
  //

  double pi;
  double w;

  pi = 4.0*atan(1.0);

  w = sinc(pi*k1/(2.0*kn)) * sinc(pi*k2/(2.0*kn)) * sinc(pi*k3/(2.0*kn));
  w = pow(w, 3);

  return w;

}

//========================
// sinc
//========================
double sinc(double x)
{
  // The sinc function
  // 
  // sinc(x) = 1  if x=0
  //           sin(x)/x   else
  //

  if(x==0)
    return 1.0;
  else
    return sin(x)/x;


}

//======================
// C1
//======================
double C1(double x)
{
  // C1 function of Jing for TSC.

  return 1.0 - pow2(sin(x)) + 2.0/15.0 * pow4(sin(x));


}
 
//====================
// get_sum
//====================
void jing(int grid, double Delta, double ***p3d2)
{
  // Calculate the mean value of the sumation for alias correction
  // Arguments:
  //      - grid  = grid size
  //      - Delta = spacing of the grid.
  //      - p3d2 = power spectrum to be corrected
  //              The corrected power spectrum is returned here.
  //
  // Comments:
  //
  
  int m, n, o;
  int k, j, i;
  int n1, n2, n3;

  double k1, k2, k3;
  
  int f;
    
  double pi;
  double kn;

  int it;  // counter for iterations

  // To fit slope
  double *x, *y; 
  double a;  // also used as temporal variable.
  double alpha;
  int l;
  
  int index_kn, index_kn_over2;
  double sum;  // to calculate c2
  double c2;   // alias correction

  double *p;   // 1d power spectrum for the fitting.
  double *phase;
  double ***p3d2_raw; // To store the very first power spectrum
                    // Correction has to be made always to this guy.

  // to test
  double hsmall = .7;
  char file[1000];
  FILE *fp;

  // maximun of term in sums
  int nmax = 2;

  pi = 4.0 * atan(1.0);
  kn = pi/Delta;

  // Some allocation:
  //=================
  x   = calloc((int)(grid/4.0+.5), sizeof(double));
  y   = calloc((int)(grid/4.0+.5), sizeof(double));
  p   = calloc((int)(sqrt(3.0)*grid+.5), sizeof(double));
  alloc_double_3(&p3d2_raw, grid, grid, grid);
  phase = calloc((int)(sqrt(3.0)*grid+.5), sizeof(double));
    
  // Identify indexes of nyquist and half nyquist:
  //==============================================
  index_kn = grid/2;
  index_kn_over2 = grid/4;

  // Calculates and stores the raw power spectrum:
  //==============================================
  get_1d(grid, Delta, p3d2, p, phase);
  for(i=0; i<grid; i++)
    for(j=0; j<grid; j++)
      for(k=0; k<grid; k++)
	p3d2_raw[i][j][k] = p3d2[i][j][k];
  
  // Iterations for alias correction:
  //=================================
  fprintf(stderr, "Iterations for alias correction...\n");
  for(it=0; it<=2; it++)  // iterations
    {
      fprintf(stderr, "Iteration %d\n", it);

      // Get 1D power to make the fit:
      //==============================
      // This is redundant the first time...
      get_1d(grid, Delta, p3d2, p, phase);

      // Output raw power spectrum:
      //==========================u=
	if(0)
	{
      sprintf(file, "raw_power.%02d.dat", it);
      if( (fp = fopen(file, "w")) == NULL)
	{
	  printf("Problems opening the output file\n");
	  exit(0);
	}
      for(k=0; k<=grid/2-1; k++)
	fprintf(fp, "%g  %g\n", 
		phase[k] / hsmall, 
		p[k] * pow3(hsmall));
      fclose(fp);
	}
      
      // Get high frequency slope:
      //==========================
      // copy into new arrays:
      l = 0;
      for(j=index_kn_over2; j<index_kn; j++)
	{
	  x[l] = log10(phase[j]);
	  y[l] = log10(p[j]);
	  l++;
	}
      // get parameters:
      cuad_min(x, y, grid/4, &a, &alpha);
      
      // this one is in logarithmic space
      fprintf(stderr, "A = %lg    B=%lg\n", a, alpha);
      // this one is in real space
      fprintf(stderr, "a = %lg    b=%lg\n", pow(10, a), alpha);
      // this one takes into account h factors
      fprintf(stderr, "A` = %lg    b=%lg\n", pow(10, a)*pow(hsmall,3+alpha), alpha);
      
      // Do the correction:
      //===================
      m = -grid/2;   // for each mode...
      for(k=0; k<=grid-1; k++)	  
	{
	  n = -grid/2;
	  for(j=0; j<=grid-1; j++)
	    {
	      o = -grid/2;
	      for(i=0; i<=grid-1; i++)	  
		{
		  // Identify index
		  f = (int)sqrt((double)pow2(m) + (double)pow2(n) + (double)pow2(o)+.5);
		  // Use only frecuencies in reasonable domain.
		  if(f>=0 && f<grid/2.0)
		    {
		      // Here we have a given vector k
		      k1 = 2.0*pi*m/(grid*Delta);
		      k2 = 2.0*pi*n/(grid*Delta);
		      k3 = 2.0*pi*o/(grid*Delta);
		      sum = 0.0;
		      // this are the sumation loops
		      for(n1=1-nmax; n1<nmax; n1++)  
			{
			  for(n2=1-nmax; n2<nmax; n2++)
			    {
			      for(n3=1-nmax; n3<nmax; n3++)
				{
				  //a = pow2(W(k1+2.0*kn*n1, 
				  //		 k2+2.0*kn*n2, 
				  //		 k3+2.0*kn*n3, kn));
				  a = pow2(W(k1 + 2.0*kn*n1, 
					     k2 + 2.0*kn*n2, 
					     k3 + 2.0*kn*n3, kn));
				  a *= pow(sqrt(pow2(k1 + 2.0*kn*n1) + 
						pow2(k2 + 2.0*kn*n2) + 
						pow2(k3 + 2.0*kn*n3)), alpha);
				  sum += a;
				}
			    }
			}
		      c2 = sum / pow(sqrt(pow2(k1) + 
					  pow2(k2) + 
					  pow2(k3)), alpha);
		      p3d2[i][j][k] = p3d2_raw[i][j][k] / c2;
		    }
		  ++o;
		}
	      ++n;
	    }
	  ++m;
	}
      
    }
	       
  free(x);
  free(y);
  
}


//========================
// get_1d
//========================
void get_1d(int grid, double Delta, double ***p3d2, double *p, double *phase)
{

  // Calculate 1d power spectrum given 3d.
  
  int m, n, o;
  int k, j, i;
  //double k1, k2, k3;
  double pi;
  int f;

  int *num;  // for the normalization

  pi = 4.0*atan(1.0);

  num = calloc((int)(sqrt(3.0)*grid+.5), sizeof(int));

  for(k=0; k<grid; k++)
    {
      p[k] = 0.0;
      num[k] = 0;
    }

  // Calculate the 1D powr spectrum:
  //================================
  m = -grid/2;
  for(k=0; k<=grid-1; k++)	  
    {
      n = -grid/2;
      for(j=0; j<=grid-1; j++)
	{
	  o = -grid/2;
	  for(i=0; i<=grid-1; i++)	  
	    {
	      //k1 = 2.0*pi*m/(grid*Delta);
	      //k2 = 2.0*pi*n/(grid*Delta);
	      //k3 = 2.0*pi*o/(grid*Delta);

	      // Identify index
	      f = (int)sqrt((double)pow2(m) + 
			    (double)pow2(n) + 
			    (double)pow2(o) + .5);
	      // Use only frecuencies in reasonable domain.
	      if(f>=0 && f<grid/2.0)
		{
		  // Make corrections:
		  //p3d2 -= C1((pi*k1)/(2*kn)) * 
		  //  C1((pi*k2)/(2*kn)) * 
		  //  C1((pi*k3)/(2*kn)) / pow3(grid);
		  //p3d2 /= pow2(W(k1, k2, k3, kn));
		  
		  // Add it to the 1D power spectrum:
		  p[f] += p3d2[i][j][k];
		  num[f]++;
		}
	      ++o;
	    }
	  ++n;
	}
      ++m;
    }

  // Normalizes de 1D power spectrum:
  //=================================
  // Delta = goes from FFT to fourier transform (see NR)
  // n = normalization of the mean value.
  // limit is n/2 because now we have only positive frecuencies.
  // We start from 1 because the first frecuency has num = 0.
  // (it gives always nan).
   for(k=0; k<grid; k++)
    {
      if(k==0)
	p[0] = 0.0;
      else
	p[k] = p[k] * 1.0 / num[k];
      //phase[k] = (double)( (2.0*pi*k/(grid*Delta)) +
      //		     (2.0*pi*(k+1)/(grid*Delta)) ) / 2.0;
      phase[k] = (double)( (2.0*pi*(k-.5)/(grid*Delta)) +
  			   (2.0*pi*(k+.5)/(grid*Delta)) ) / 2.0;
    }

  free(num);

}
